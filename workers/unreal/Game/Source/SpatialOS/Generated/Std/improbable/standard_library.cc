// Generated by SpatialOS codegen. DO NOT EDIT!
// source: improbable/standard_library.schema
#include "improbable/standard_library.h"

namespace improbable {

// Serialization helpers.
//----------------------------------------------------------------

namespace detail {

void Write_Coordinates(
    const ::improbable::Coordinates& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddDouble(object, 1, data.x());
  ::worker::detail::internal::Pbio_AddDouble(object, 2, data.y());
  ::worker::detail::internal::Pbio_AddDouble(object, 3, data.z());
}

::improbable::Coordinates Read_Coordinates(::worker::detail::internal::Pbio_Object* object) {
  auto _x = ::worker::detail::internal::Pbio_GetDouble(object, 1);
  auto _y = ::worker::detail::internal::Pbio_GetDouble(object, 2);
  auto _z = ::worker::detail::internal::Pbio_GetDouble(object, 3);
  return {
      std::move(_x),
      std::move(_y),
      std::move(_z)};
}

void Write_WorkerRequirementSet(
    const ::improbable::WorkerRequirementSet& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.attribute_set()) {
    ::improbable::detail::Write_WorkerAttributeSet(item, ::worker::detail::internal::Pbio_AddObject(object, 1));
  }
}

::improbable::WorkerRequirementSet Read_WorkerRequirementSet(::worker::detail::internal::Pbio_Object* object) {
  ::worker::List< ::improbable::WorkerAttributeSet > _attribute_set;
  auto _attribute_set_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_set_count; ++index) {
    _attribute_set.emplace_back(::improbable::detail::Read_WorkerAttributeSet(::worker::detail::internal::Pbio_IndexObject(object, 1, index)));
  }
  return {
      std::move(_attribute_set)};
}

void Write_EntityAclData(
    const ::improbable::EntityAclData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_WorkerRequirementSet(data.read_acl(), ::worker::detail::internal::Pbio_AddObject(object, 1));
  for (const auto& item : data.component_write_acl()) {
    auto pair = ::worker::detail::internal::Pbio_AddObject(object, 2);
    ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
    ::improbable::detail::Write_WorkerRequirementSet(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
  }
}

::improbable::EntityAclData Read_EntityAclData(::worker::detail::internal::Pbio_Object* object) {
  auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(object, 1));
  ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
  auto _component_write_acl_count = ::worker::detail::internal::Pbio_GetObjectCount(object, 2);
  for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
    auto pair = ::worker::detail::internal::Pbio_IndexObject(object, 2, index);
    _component_write_acl.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(pair, 2)));
  }
  return {
      std::move(_read_acl),
      std::move(_component_write_acl)};
}

void Write_MetadataData(
    const ::improbable::MetadataData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::worker::detail::internal::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(data.entity_type().data()), static_cast<std::uint32_t>(data.entity_type().size()));
}

::improbable::MetadataData Read_MetadataData(::worker::detail::internal::Pbio_Object* object) {
  auto _entity_type = [object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(object, 1)}; }();
  return {
      std::move(_entity_type)};
}

void Write_PersistenceData(const ::improbable::PersistenceData&, ::worker::detail::internal::Pbio_Object*) {}

::improbable::PersistenceData Read_PersistenceData(::worker::detail::internal::Pbio_Object*) {
  return {};
}

void Write_PositionData(
    const ::improbable::PositionData& data, ::worker::detail::internal::Pbio_Object* object) {
  ::improbable::detail::Write_Coordinates(data.coords(), ::worker::detail::internal::Pbio_AddObject(object, 1));
}

::improbable::PositionData Read_PositionData(::worker::detail::internal::Pbio_Object* object) {
  auto _coords = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(object, 1));
  return {
      std::move(_coords)};
}

void Write_WorkerAttributeSet(
    const ::improbable::WorkerAttributeSet& data, ::worker::detail::internal::Pbio_Object* object) {
  for (const auto& item : data.attribute()) {
    ::worker::detail::internal::Pbio_AddBytes(object, 1, reinterpret_cast<const std::uint8_t*>(item.data()), static_cast<std::uint32_t>(item.size()));
  }
}

::improbable::WorkerAttributeSet Read_WorkerAttributeSet(::worker::detail::internal::Pbio_Object* object) {
  ::worker::List< std::string > _attribute;
  auto _attribute_count = ::worker::detail::internal::Pbio_GetBytesCount(object, 1);
  for (std::uint32_t index = 0; index < _attribute_count; ++index) {
    auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_IndexBytes(object, 1, index));
    _attribute.emplace_back(_buffer, _buffer + ::worker::detail::internal::Pbio_IndexBytesLength(object, 1, index));
  }
  return {
      std::move(_attribute)};
}

namespace {

void VtableFree_EntityAcl(
    ::worker::ComponentId, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::EntityAclData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_EntityAcl >::free(handle);
  }
}

void* VtableCopy_EntityAcl(
    ::worker::ComponentId, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::EntityAclData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_EntityAcl >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 50);
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 1)) {
        auto _read_acl = ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(state_object, 1));
        object->read_acl().emplace(std::move(_read_acl));
      }
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 2) || fields_to_clear.count(2)) {
        ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > _component_write_acl;
        auto _component_write_acl_count = ::worker::detail::internal::Pbio_GetObjectCount(state_object, 2);
        for (std::uint32_t index = 0; index < _component_write_acl_count; ++index) {
          auto pair = ::worker::detail::internal::Pbio_IndexObject(state_object, 2, index);
          _component_write_acl.emplace(::worker::detail::internal::Pbio_GetUint32(pair, 1), ::improbable::detail::Read_WorkerRequirementSet(::worker::detail::internal::Pbio_GetObject(pair, 2)));
        }
        object->component_write_acl().emplace(std::move(_component_write_acl));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::EntityAclData >::allocate(::improbable::detail::Read_EntityAclData(::worker::detail::internal::Pbio_GetObject(root, 50)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_EntityAcl(
    ::worker::ComponentId, std::uint8_t handle_type,
    const void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< const ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::EntityAcl::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 50);
      if (data.read_acl()) {
        ::improbable::detail::Write_WorkerRequirementSet((*data.read_acl()), ::worker::detail::internal::Pbio_AddObject(state_object, 1));
      }
      if (data.component_write_acl()) {
        if (data.component_write_acl()->empty()) {
          ::worker::detail::internal::Pbio_AddUint32(root, /* fields_to_clear */ 1, 2);
        }
        for (const auto& item : (*data.component_write_acl())) {
          auto pair = ::worker::detail::internal::Pbio_AddObject(state_object, 2);
          ::worker::detail::internal::Pbio_AddUint32(pair, 1, item.first);
          ::improbable::detail::Write_WorkerRequirementSet(item.second, ::worker::detail::internal::Pbio_AddObject(pair, 2));
        }
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_EntityAclData(
        ::worker::detail::ClientHandle< ::improbable::EntityAclData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 50));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 50);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 50);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Metadata(
    ::worker::ComponentId, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::MetadataData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Metadata >::free(handle);
  }
}

void* VtableCopy_Metadata(
    ::worker::ComponentId, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::MetadataData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Metadata >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Metadata(
    ::worker::ComponentId, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::Metadata::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 53);
      if (::worker::detail::internal::Pbio_GetBytesCount(state_object, 1)) {
        auto _entity_type = [state_object] { auto _buffer = reinterpret_cast<const char*>(::worker::detail::internal::Pbio_GetBytes(state_object, 1)); return std::string{_buffer, _buffer + ::worker::detail::internal::Pbio_GetBytesLength(state_object, 1)}; }();
        object->entity_type().emplace(std::move(_entity_type));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::MetadataData >::allocate(::improbable::detail::Read_MetadataData(::worker::detail::internal::Pbio_GetObject(root, 53)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Metadata(
    ::worker::ComponentId, std::uint8_t handle_type,
    const void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< const ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::Metadata::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 53);
      if (data.entity_type()) {
        ::worker::detail::internal::Pbio_AddBytes(state_object, 1, reinterpret_cast<const std::uint8_t*>((*data.entity_type()).data()), static_cast<std::uint32_t>((*data.entity_type()).size()));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_MetadataData(
        ::worker::detail::ClientHandle< ::improbable::MetadataData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 53));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 53);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 53);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Position(
    ::worker::ComponentId, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Position::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::PositionData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Position >::free(handle);
  }
}

void* VtableCopy_Position(
    ::worker::ComponentId, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Position::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::PositionData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Position >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Position(
    ::worker::ComponentId, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Position::Update >::allocate();
    auto* object =
       &::worker::detail::ClientHandle< ::improbable::Position::Update >::get_mutable(*handle_out);
    {
      std::vector<std::uint32_t> fields_to_clear_vector;
      fields_to_clear_vector.insert(
          fields_to_clear_vector.end(),
          ::worker::detail::internal::Pbio_GetUint32Count(root, /* fields to clear */ 1), 0);
      ::worker::detail::internal::Pbio_GetUint32List(
         root, /* fields to clear */ 1, fields_to_clear_vector.data());
      std::set<std::uint32_t> fields_to_clear{fields_to_clear_vector.begin(),
                                              fields_to_clear_vector.end()};
      auto state_object = ::worker::detail::internal::Pbio_GetObject(
          ::worker::detail::internal::Pbio_GetObject(root, /* entity_state */ 2), 54);
      if (::worker::detail::internal::Pbio_GetObjectCount(state_object, 1)) {
        auto _coords = ::improbable::detail::Read_Coordinates(::worker::detail::internal::Pbio_GetObject(state_object, 1));
        object->coords().emplace(std::move(_coords));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::PositionData >::allocate(::improbable::detail::Read_PositionData(::worker::detail::internal::Pbio_GetObject(root, 54)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Position(
    ::worker::ComponentId, std::uint8_t handle_type,
    const void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< const ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    const auto& data = ::worker::detail::ClientHandle< ::improbable::Position::Update >::get(handle);
    {
      auto state_object = ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 54);
      if (data.coords()) {
        ::improbable::detail::Write_Coordinates((*data.coords()), ::worker::detail::internal::Pbio_AddObject(state_object, 1));
      }
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_PositionData(
        ::worker::detail::ClientHandle< ::improbable::PositionData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 54));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 54);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 54);
  }
}

}  // anonymous namespace

namespace {

void VtableFree_Persistence(
    ::worker::ComponentId, std::uint8_t handle_type,
    void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(internal_handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::worker::detail::ClientHandle< ::improbable::PersistenceData >::free(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::ClientHandle< GenericCommandObject_Persistence >::free(handle);
  }
}

void* VtableCopy_Persistence(
    ::worker::ComponentId, std::uint8_t handle_type, const void* internal_handle) {
  auto* handle = reinterpret_cast< ::worker::detail::ClientHandleBase* >(const_cast<void*>(internal_handle));
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    return ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    return ::worker::detail::ClientHandle< ::improbable::PersistenceData >::new_copy(handle);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST ||
             handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    return ::worker::detail::ClientHandle<
        GenericCommandObject_Persistence >::new_copy(handle);
  }
  return nullptr;
}

std::uint8_t VtableDeserialize_Persistence(
    ::worker::ComponentId, std::uint8_t handle_type,
    ::worker::detail::internal::Pbio_Object* root, void** internal_handle_out) {
  auto** handle_out = reinterpret_cast< ::worker::detail::ClientHandleBase** >(internal_handle_out);
  *handle_out = nullptr;
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::Persistence::Update >::allocate();
    {
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    *handle_out = ::worker::detail::ClientHandle< ::improbable::PersistenceData >::allocate(::improbable::detail::Read_PersistenceData(::worker::detail::internal::Pbio_GetObject(root, 55)));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
  }
  return true;
}

void VtableSerialize_Persistence(
    ::worker::ComponentId, std::uint8_t handle_type,
    const void* internal_handle, ::worker::detail::internal::Pbio_Object* root) {
  const auto* handle = reinterpret_cast< const ::worker::detail::ClientHandleBase* >(internal_handle);
  static_cast<void>(handle);
  if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_UPDATE) {
    {
      ::worker::detail::internal::Pbio_AddObject(
          ::worker::detail::internal::Pbio_AddObject(root, /* entity_state */ 2), 55);
    }
    {
    }
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_SNAPSHOT) {
    ::improbable::detail::Write_PersistenceData(
        ::worker::detail::ClientHandle< ::improbable::PersistenceData >::get(handle),
        ::worker::detail::internal::Pbio_AddObject(root, 55));
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_REQUEST) {
    ::worker::detail::internal::Pbio_AddObject(root, 55);
  } else if (handle_type == ::worker::detail::internal::WORKER_PROTOCOL_CLIENT_HANDLE_TYPE_RESPONSE) {
    ::worker::detail::internal::Pbio_AddObject(root, 55);
  }
}

}  // anonymous namespace

}  // ::detail

// Implementation of Coordinates.
//----------------------------------------------------------------

Coordinates::Coordinates(
    double x,
    double y,
    double z)
: _x{x}
, _y{y}
, _z{z} {}

Coordinates::Coordinates()
: _x{0}
, _y{0}
, _z{0} {}

bool Coordinates::operator==(const Coordinates& value) const {
  return
      _x == value._x &&
      _y == value._y &&
      _z == value._z;
}

bool Coordinates::operator!=(const Coordinates& value) const {
  return !operator==(value);
}

double Coordinates::x() const {
  return _x;
}

double& Coordinates::x() {
  return _x;
}

Coordinates& Coordinates::set_x(double value) {
  _x = value;
  return *this;
}

double Coordinates::y() const {
  return _y;
}

double& Coordinates::y() {
  return _y;
}

Coordinates& Coordinates::set_y(double value) {
  _y = value;
  return *this;
}

double Coordinates::z() const {
  return _z;
}

double& Coordinates::z() {
  return _z;
}

Coordinates& Coordinates::set_z(double value) {
  _z = value;
  return *this;
}

// Implementation of WorkerRequirementSet.
//----------------------------------------------------------------

WorkerRequirementSet::WorkerRequirementSet(const ::worker::List< ::improbable::WorkerAttributeSet >& attribute_set)
: _attribute_set{attribute_set} {}

WorkerRequirementSet::WorkerRequirementSet() {}

bool WorkerRequirementSet::operator==(const WorkerRequirementSet& value) const {
  return
      _attribute_set == value._attribute_set;
}

bool WorkerRequirementSet::operator!=(const WorkerRequirementSet& value) const {
  return !operator==(value);
}

const ::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() const {
  return _attribute_set;
}

::worker::List< ::improbable::WorkerAttributeSet >& WorkerRequirementSet::attribute_set() {
  return _attribute_set;
}

WorkerRequirementSet& WorkerRequirementSet::set_attribute_set(const ::worker::List< ::improbable::WorkerAttributeSet >& value) {
  _attribute_set = value;
  return *this;
}

// Implementation of EntityAclData.
//----------------------------------------------------------------

EntityAclData::EntityAclData(
    const ::improbable::WorkerRequirementSet& read_acl,
    const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& component_write_acl)
: _read_acl{read_acl}
, _component_write_acl{component_write_acl} {}

EntityAclData::EntityAclData() {}

bool EntityAclData::operator==(const EntityAclData& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAclData::operator!=(const EntityAclData& value) const {
  return !operator==(value);
}

const ::improbable::WorkerRequirementSet& EntityAclData::read_acl() const {
  return _read_acl;
}

::improbable::WorkerRequirementSet& EntityAclData::read_acl() {
  return _read_acl;
}

EntityAclData& EntityAclData::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl = value;
  return *this;
}

const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() const {
  return _component_write_acl;
}

::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& EntityAclData::component_write_acl() {
  return _component_write_acl;
}

EntityAclData& EntityAclData::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl = value;
  return *this;
}

// Implementation of MetadataData.
//----------------------------------------------------------------

MetadataData::MetadataData(const std::string& entity_type)
: _entity_type{entity_type} {}

MetadataData::MetadataData() {}

bool MetadataData::operator==(const MetadataData& value) const {
  return
      _entity_type == value._entity_type;
}

bool MetadataData::operator!=(const MetadataData& value) const {
  return !operator==(value);
}

const std::string& MetadataData::entity_type() const {
  return _entity_type;
}

std::string& MetadataData::entity_type() {
  return _entity_type;
}

MetadataData& MetadataData::set_entity_type(const std::string& value) {
  _entity_type = value;
  return *this;
}

// Implementation of PersistenceData.
//----------------------------------------------------------------

PersistenceData::PersistenceData() {}

bool PersistenceData::operator==(const PersistenceData&) const {
  return true;
}

bool PersistenceData::operator!=(const PersistenceData& value) const {
  return !operator==(value);
}

// Implementation of PositionData.
//----------------------------------------------------------------

PositionData::PositionData(const ::improbable::Coordinates& coords)
: _coords{coords} {}

PositionData::PositionData() {}

bool PositionData::operator==(const PositionData& value) const {
  return
      _coords == value._coords;
}

bool PositionData::operator!=(const PositionData& value) const {
  return !operator==(value);
}

const ::improbable::Coordinates& PositionData::coords() const {
  return _coords;
}

::improbable::Coordinates& PositionData::coords() {
  return _coords;
}

PositionData& PositionData::set_coords(const ::improbable::Coordinates& value) {
  _coords = value;
  return *this;
}

// Implementation of WorkerAttributeSet.
//----------------------------------------------------------------

WorkerAttributeSet::WorkerAttributeSet(const ::worker::List< std::string >& attribute)
: _attribute{attribute} {}

WorkerAttributeSet::WorkerAttributeSet() {}

bool WorkerAttributeSet::operator==(const WorkerAttributeSet& value) const {
  return
      _attribute == value._attribute;
}

bool WorkerAttributeSet::operator!=(const WorkerAttributeSet& value) const {
  return !operator==(value);
}

const ::worker::List< std::string >& WorkerAttributeSet::attribute() const {
  return _attribute;
}

::worker::List< std::string >& WorkerAttributeSet::attribute() {
  return _attribute;
}

WorkerAttributeSet& WorkerAttributeSet::set_attribute(const ::worker::List< std::string >& value) {
  _attribute = value;
  return *this;
}

// Implementation of EntityAcl.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId EntityAcl::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
EntityAcl::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      50,
      &::improbable::detail::VtableFree_EntityAcl,
      &::improbable::detail::VtableCopy_EntityAcl,
      &::improbable::detail::VtableDeserialize_EntityAcl,
      &::improbable::detail::VtableSerialize_EntityAcl,
  };
  return vtable;
}

bool EntityAcl::Update::operator==(const EntityAcl::Update& value) const {
  return
      _read_acl == value._read_acl &&
      _component_write_acl == value._component_write_acl;
}

bool EntityAcl::Update::operator!=(const EntityAcl::Update& value) const {
  return !operator==(value);
}

EntityAcl::Update EntityAcl::Update::FromInitialData(const ::improbable::EntityAclData& data) {
  EntityAcl::Update update;
  update._read_acl.emplace(data.read_acl());
  update._component_write_acl.emplace(data.component_write_acl());
  return update;
}

::improbable::EntityAclData EntityAcl::Update::ToInitialData() const {
  return ::improbable::EntityAclData(
      *_read_acl,
      *_component_write_acl);
}

void EntityAcl::Update::ApplyTo(::improbable::EntityAclData& data) const {
  if (_read_acl) {
    data.set_read_acl(*_read_acl);
  }
  if (_component_write_acl) {
    data.set_component_write_acl(*_component_write_acl);
  }
}

const ::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() const {
  return _read_acl;
}

::worker::Option< ::improbable::WorkerRequirementSet >& EntityAcl::Update::read_acl() {
  return _read_acl;
}

EntityAcl::Update& EntityAcl::Update::set_read_acl(const ::improbable::WorkerRequirementSet& value) {
  _read_acl.emplace(value); return *this;
}

const ::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() const {
  return _component_write_acl;
}

::worker::Option< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >& EntityAcl::Update::component_write_acl() {
  return _component_write_acl;
}

EntityAcl::Update& EntityAcl::Update::set_component_write_acl(const ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet >& value) {
  _component_write_acl.emplace(value); return *this;
}

// Implementation of Metadata.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Metadata::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Metadata::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      53,
      &::improbable::detail::VtableFree_Metadata,
      &::improbable::detail::VtableCopy_Metadata,
      &::improbable::detail::VtableDeserialize_Metadata,
      &::improbable::detail::VtableSerialize_Metadata,
  };
  return vtable;
}

bool Metadata::Update::operator==(const Metadata::Update& value) const {
  return
      _entity_type == value._entity_type;
}

bool Metadata::Update::operator!=(const Metadata::Update& value) const {
  return !operator==(value);
}

Metadata::Update Metadata::Update::FromInitialData(const ::improbable::MetadataData& data) {
  Metadata::Update update;
  update._entity_type.emplace(data.entity_type());
  return update;
}

::improbable::MetadataData Metadata::Update::ToInitialData() const {
  return ::improbable::MetadataData(*_entity_type);
}

void Metadata::Update::ApplyTo(::improbable::MetadataData& data) const {
  if (_entity_type) {
    data.set_entity_type(*_entity_type);
  }
}

const ::worker::Option< std::string >& Metadata::Update::entity_type() const {
  return _entity_type;
}

::worker::Option< std::string >& Metadata::Update::entity_type() {
  return _entity_type;
}

Metadata::Update& Metadata::Update::set_entity_type(const std::string& value) {
  _entity_type.emplace(value); return *this;
}

// Implementation of Position.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Position::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Position::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      54,
      &::improbable::detail::VtableFree_Position,
      &::improbable::detail::VtableCopy_Position,
      &::improbable::detail::VtableDeserialize_Position,
      &::improbable::detail::VtableSerialize_Position,
  };
  return vtable;
}

bool Position::Update::operator==(const Position::Update& value) const {
  return
      _coords == value._coords;
}

bool Position::Update::operator!=(const Position::Update& value) const {
  return !operator==(value);
}

Position::Update Position::Update::FromInitialData(const ::improbable::PositionData& data) {
  Position::Update update;
  update._coords.emplace(data.coords());
  return update;
}

::improbable::PositionData Position::Update::ToInitialData() const {
  return ::improbable::PositionData(*_coords);
}

void Position::Update::ApplyTo(::improbable::PositionData& data) const {
  if (_coords) {
    data.set_coords(*_coords);
  }
}

const ::worker::Option< ::improbable::Coordinates >& Position::Update::coords() const {
  return _coords;
}

::worker::Option< ::improbable::Coordinates >& Position::Update::coords() {
  return _coords;
}

Position::Update& Position::Update::set_coords(const ::improbable::Coordinates& value) {
  _coords.emplace(value); return *this;
}

// Implementation of Persistence.
//----------------------------------------------------------------

constexpr const ::worker::ComponentId Persistence::ComponentId;

const ::worker::detail::internal::WorkerProtocol_ComponentVtable&
Persistence::Vtable() {
  static const ::worker::detail::internal::WorkerProtocol_ComponentVtable vtable = {
      55,
      &::improbable::detail::VtableFree_Persistence,
      &::improbable::detail::VtableCopy_Persistence,
      &::improbable::detail::VtableDeserialize_Persistence,
      &::improbable::detail::VtableSerialize_Persistence,
  };
  return vtable;
}

bool Persistence::Update::operator==(const Persistence::Update&) const {
  return true;
}

bool Persistence::Update::operator!=(const Persistence::Update& value) const {
  return !operator==(value);
}

Persistence::Update Persistence::Update::FromInitialData(const ::improbable::PersistenceData&) {
  return Persistence::Update{};
}

::improbable::PersistenceData Persistence::Update::ToInitialData() const {
  return ::improbable::PersistenceData();
}

void Persistence::Update::ApplyTo(::improbable::PersistenceData&) const {
}

}  // ::improbable

std::size_t std::hash< ::improbable::Coordinates >::operator()(const ::improbable::Coordinates& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< double >{}(value.x());
  result = (result * 977) + std::hash< double >{}(value.y());
  result = (result * 977) + std::hash< double >{}(value.z());
  return result;
}

std::size_t std::hash< ::improbable::WorkerRequirementSet >::operator()(const ::improbable::WorkerRequirementSet& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::List< ::improbable::WorkerAttributeSet > >{}(value.attribute_set());
  return result;
}

std::size_t std::hash< ::improbable::EntityAclData >::operator()(const ::improbable::EntityAclData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::WorkerRequirementSet >{}(value.read_acl());
  result = (result * 977) + std::hash< ::worker::Map< std::uint32_t, ::improbable::WorkerRequirementSet > >{}(value.component_write_acl());
  return result;
}

std::size_t std::hash< ::improbable::MetadataData >::operator()(const ::improbable::MetadataData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< std::string >{}(value.entity_type());
  return result;
}

std::size_t std::hash< ::improbable::PersistenceData >::operator()(const ::improbable::PersistenceData& ) const {
  size_t result = 1327;
  return result;
}

std::size_t std::hash< ::improbable::PositionData >::operator()(const ::improbable::PositionData& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::improbable::Coordinates >{}(value.coords());
  return result;
}

std::size_t std::hash< ::improbable::WorkerAttributeSet >::operator()(const ::improbable::WorkerAttributeSet& value) const {
  size_t result = 1327;
  result = (result * 977) + std::hash< ::worker::List< std::string > >{}(value.attribute());
  return result;
}
